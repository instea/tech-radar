[{"name":"Docker","ring":"ADOPT","quadrant":"Infrastructure and platforms","isNew":"TRUE","description":"Docker is very usefull for local development (e.g. to run DB). <br><br>For a production there are already two possibilities - run applications in Docker or write applications in Serverless fashion (they can also co-exists). Apart obvious pros and cons, the decision factor shall be price. For steady load, &quot;standard&quot; dockerized applications are cheaper and there are no &quot;hidden&quot; costs like using secrets. Also resource utilization (CPU/memory) is typically better (two lambda functions does not share the memory) again leading to better runtime costs.<br><br>Pros: Predicable - same environment everywhere, Predicable runtime costs, Better developer experience<br>Cons: Less scalable than serverless, Harder operations/maintanance"},{"name":"React","ring":"ADOPT","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"Every frontend developer in the company has knowledge of React. Reasons not to use React can include performance and package size concerns, where a good alternative might be Svelte. Reasons for not using React arise when we need just clean, lightweight, minimal code. SolidJS is like React with signals, addressing what React lacks compared to newer players, and it seems they don&apos;t even want to adopt it. Qwik is another potential alternative in terms of performance.<br>Advantages: most commonly used UI library, community support, speed, widespread adoption within the company.<br>Disadvantages: one minor drawback is that many solutions require additional coding, there are frameworks with built-in solutions, and in terms of speed, there are other options available."},{"name":"PostgreSQL","ring":"ADOPT","quadrant":"Data","isNew":"TRUE","description":"Well known and used relation database. <br>With relation data PostgreSQL is mostly right choice.<br>Has tons of extensions and big community behind.<br><br>Cons: Scalability can be problem<br>Pros: Transactions, relations, joins"},{"name":"Mongo","ring":"TRIAL","quadrant":"Data","isNew":"TRUE","description":"Most popular NoSQL database.<br>Make sense to use this database when data is in document structure and have only few relations.<br><br>Pros: Scalability, speed<br>Cons: No relations and Joins, has no guarantees of atomicity, consistency, isolation, or durability."},{"name":"Kubernetes","ring":"TRIAL","quadrant":"Infrastructure and platforms","isNew":"TRUE","description":"Kubernetes is popular container orchestration platform.<br>It enables scalability, service discovery, self-healing and many more.<br><br>It is possible to use managed or self-hosted. We prefer managed Kubernetes.<br><br>While Kubernetes is suitable for robust applications with a large number of microservices, for smaller applications may be Docker Swarm a suitable alternative. Docker Swarm is simpler, but supports less advanced functions (eg audit log, pod security policies, advanced scheduling - node affinity, ...)<br><br>Pros: Widely used, robust, extensible (CRD), tooling (eg. Kyverno for pod security)<br>Cons: complexity, overkill for simple applications"},{"name":"Tailwind","ring":"ASSESS","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"Tailwind provides CSS utilities for easier development of &quot;pixel-perfect&quot; applications.<br><br>Designing the application with Tailwind is convenient, but without team rules and component extraction, it is easy to make the design inconsistent.<br>For avoiding the inconsistency, it is advised to use Tailwind with component library, and enforce consistent styles.<br><br>Pros: easy to use, rapid development, mobile-first<br>Cons: possible style inconsistencies, verbose markup"},{"name":"AWS","ring":"ADOPT","quadrant":"Infrastructure and platforms","isNew":"TRUE","description":"We have picked AWS as a industry standard for running applications in a cloud. And since we have biggest experience with it, we stick to it. However it might not be good enough for special needs like AI.<br><br>Pros: Proven cloud provider<br>Cons: AI services are not that rich as in case of Azure or Google."},{"name":"Vite","ring":"ADOPT","quadrant":"Tools and techniques","isNew":"TRUE","description":"Vite.js is a modern, fast, and efficient build tool and dev server. It’s ideal for non-server-rendered apps, supports ES6, JSX, TypeScript, CSS preprocessors, and other frameworks like Vue. It’s not optimal for server rendering.<br><br>Pros:<br>- Fast and efficient, compiles and reloads only changed code<br>- Pre-bundles dependencies using esbuild<br>- Pre-configured Rollup build<br><br>Cons:<br>- Old browsers dont support its features<br>- Integration require significant changes<br>- Does not do type checking"},{"name":"Typescript","ring":"ADOPT","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"TypeScript brings (optional) type safety to the codebase. While JavaScript might be a good choice for prototypes and small projects, in general TypeScript scales better for medium to large projects with multiple people working on them. Since it requires transpilation step, setup could get more complicated and might collide with other libraries (e.g. we experienced issues while setting up TS for serverless).<br><br>Pros: Type safety, Tooling - auto-completion, refactoring, code navigation, ...<br>Cons: More complicated setup, Increased code verbosity"},{"name":"Java","ring":"ADOPT","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"Java is a robust technology of choice, especially when performance and robustness are key, making it a preferred choice for large-scale projects that require high levels of stability and scalability.<br>Kotlin is the successor to Java, introducing a number of modern features while maintaining interoperability with existing Java codebases.<br>Node.js is favoured for projects where rapid development is a priority, providing a lightweight and efficient environment.<br>The choice depends on the team.<br><br>Pros: performance, features such as transaction handling, metrics, actuator, proven for large-scale applications, strong community support<br>Cons: development speed, memory consumption, lack of features in older versions, null safety"},{"name":"Serverless","ring":"ADOPT","quadrant":"Infrastructure and platforms","isNew":"TRUE","description":"Serverless (and mainly lambda functions) are alternative (and sometimes complimentary) approach to standard server based architecture.<br><br>Development is typically more complicated. Although frameworks like Serverless.com allows you certain level of vendor independence, at least some parts are bound to specific platform.<br><br>See Docker for more details about pros and cons. Things like memory leaks affects only one lambda but at the cost of worse memory/cpu utilization due to isolation.<br><br>Pros: Scallable, easier DevOps<br>Cons: Worse DX, Pricing model is much more complex"},{"name":"Apollo-graphql","ring":"ADOPT","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"Good choice for basic application without any special requirements.<br>Can also be combined with REST.<br>It allows API client to choose schema of response.<br>API defines resolvers and queries.<br>Response is created as union of resolvers.<br><br>Pros: Flexibility for API client, data efficiency, data subscription model<br>Cons: Complexity(based on project), performance"},{"name":"Next.js","ring":"TRIAL","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"Full framework framework built on top of React capable of bundling and serving files.<br>Supports full stack applications &apos;out-of-box&apos;, can be used either with Next server or with custom server (e.g. Express.js).<br><br>Pros:<br>- Static Site Generation (SSG) and Server Side Rendering (SSR) <br>- App routing<br>- Data caching<br>- Performance<br>Cons:<br>- No state management out of the box<br>- Complexity (for smaller apps)"},{"name":"Redis","ring":"TRIAL","quadrant":"Data","isNew":"TRUE","description":"(Key, value) pair database, but can do a lot more (e.g data structures). Is often used as distrubuted cache.<br>Has also UI. Has adapter for most programming languages. Functionality can be extended with plugins<br><br>Alternatives:<br> - MemoryDb<br><br>Pros:<br> - Performance<br> - Light weight<br><br>Cons:<br> - Not durable by default (does not guarantee succesfull write)"},{"name":"Jenkins","ring":"HOLD","quadrant":"Infrastructure and platforms","isNew":"TRUE","description":"Is DevOps tool. Is used for task automatization. Standalone technology with learning curve.<br>Is installed on bare metal manually. Is not coupled with repositories, this brings flexibility.<br>Uses plugin system for enhancing functionality, plugins are mainly created by community.<br><br>Alternatives:<br> - Github actions<br> - Gitlab ci<br><br>Pros:<br> - Pricing<br> - Repository flexibility<br><br>Cons:<br> - Complexity<br> - Versioning (e.g different Java versions for each Job)<br> - Plugin system (many times deprecated and not secure plugins)"},{"name":"Gitlab/Github CI","ring":"ADOPT","quadrant":"Infrastructure and platforms","isNew":"TRUE","description":"DevOps platform as a service. Is coupled with repository. Is based on plugin(action) system from community, but with some official.<br>In super specific and complex tasks can lack functionality. In general cases is easy to use. Works out of the box. <br><br>Alternatives:<br> - Jenkins<br><br>Pros:<br> - Easy to use<br> - No setup<br><br>Cons:<br> - Pricing (in terms of long runnign jobs)<br> - Coupled to repository"},{"name":"OpenAPI","ring":"ADOPT","quadrant":"Tools and techniques","isNew":"TRUE","description":"<br>Also known as Swagger, OpenAPI is a specification that describes resources in a REST API. It&apos;s an essential tool when creating REST APIs because it allows for detailed and systematic descriptions of each endpoint and its functions. OpenAPI can also be generated from an existing API, which facilitates its management and documentation. When deciding whether to create a specification or code first, it makes sense to start with the specification. This allows for better division of work because each team (such as frontend or backend) can rely on a clear description and start working on their part of the project. However, in smaller projects, code is often implemented first, and the specification is created later. Some languages cannot easily generate OpenAPI directly from code, which can cause some difficulties in integration and API management. There are likely no alternatives with the same scope as OpenAPI.<br><br>Advantages:<br>Allows for detailed descriptions of REST API resources<br>Assists in systematic API documentation<br>Ability to generate from an existing API<br>Disadvantages: Some languages cannot easily generate OpenAPI directly from code"},{"name":"Kafka","ring":"TRIAL","quadrant":"Data","isNew":"TRUE","description":"It is more streaming solution but can be used also as messaging (where it is quite flexible, e.g. combining queue and topics distribution patterns).<br><br>Messages have its own retention, thus it is possible to replay/look back on older messages (which is usefull for different streaming aggregation or just to be correct corrupted data by replaying older inputs).<br><br>It has very reliable and inherently fault tollerant. When properly configured (e.g. partitions), it is also very scallable. On the other hand it might be also more expensive (cost or resource wise) than simpler solutions. Although it is performant (throughput, ...), it has slight latency (~ tens of ms). <br><br>Alternatives:<br>- SQS<br>- RabbitMq<br>- Redis<br><br>Pros: reliable, fault-tolerant, scalable, pretty flexible<br>Cons: expensive"},{"name":"React-admin","ring":"TRIAL","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"React Admin is a framework for building admin interfaces. It provides an extensive library of components and helper functions that speed up the implementation of CRUD pages based on the data model. It is a frontend-only framework and has automatic adapters for REST APIs that follow certain conventions, but it can also be used with any API by implementing an adapter.<br><br>Alternatives:<br>- Headless CMS systems like Strapi<br>- Custom UI with component libraries like Ant Design, Material UI, ...<br><br>Pros:<br>- Steep learning curve<br>- Fast development<br>- Flexibility and extensibility of the framework<br><br>Cons:<br>- FE only framework"},{"name":"Expo","ring":"TRIAL","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"Expo simplifies React Native app development by abstracting complexities, providing a streamlined experience for developers.<br><br>Alternatives:<br> - React Native (vanila)<br><br>Pros:<br>- Fast multiplatform development<br>- Handles dependencies<br>- Over the air updates<br>- Expo libs and APIs<br>- Simple build by abstracting configuration<br>- EAS (build, submit, .., handled by Expo)<br>- ExpoGo (local and served)<br><br>Cons:<br> - Limited Native Modules<br>- Limited build customization<br>- Bundle size"},{"name":"Kotlin","ring":"ASSESS","quadrant":"Languages and Frameworks","isNew":"TRUE","description":"Kotlin is a modern programming language that runs on the Java Virtual Machine (JVM), offering full interoperability with Java. Designed to be concise, expressive, and safe, Kotlin reduces the amount of boilerplate code, which makes it a popular choice for Android app development and server-side applications.<br><br>Key features include null safety to avoid NullPointerExceptions, extension functions for adding methods to classes without modifying their source code, and higher-order functions for facilitating functional programming patterns. Kotlin also supports coroutines at the language level, enabling efficient asynchronous programming and concurrency management.<br><br>Kotlin is inherently safe due to its design, which prevents common programming errors by design. It&apos;s also highly scalable, but compilation time can be longer compared to Java.<br><br>Alternatives:<br> - Java<br><br>Pros:<br> - Concise and expressive syntax, null safety, interoperability with Java, multiplatform support, strong community and corporate support (especially from JetBrains and Google).<br><br>Cons:<br> - Steeper learning curve for developers unfamiliar with modern language features, potentially longer compilation times, and less extensive library ecosystem compared to Java (although rapidly growing)."}]